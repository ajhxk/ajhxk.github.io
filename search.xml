<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[perforManace]]></title>
    <url>%2F2018%2F11%2F27%2FperforManace%2F</url>
    <content type="text"><![CDATA[以下是关于页面性能的一些整理： 提升页面性能的方法：1、资源压缩合并，减少HTTP请求，开启gzip压缩2、非核心代码异步加载 -&gt; 异步加载的方式 -&gt; 异步加载的区别3、利用浏览器缓存 -&gt; 缓存的分类 -&gt; 缓存的原理4、使用cdn5、预解析DNS 2、非核心代码异步加载 -&gt; 异步加载的方式 -&gt; 异步加载的区别1、异步加载的方式： 1) 动态脚本加载 2)defer 3)async2、异步加载的区别 1)defer是在HTML解析完之后才会执行,如果是多个，按照加载的顺序依次执行 2)async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关 3、利用浏览器缓存 -&gt; 缓存的分类 -&gt; 缓存的原理1、缓存的分类:1)强缓存(下次访问该资源时,直接使用缓存)&emsp;&emsp;Expires(过期时间) Expires:Thu,21 Jan 2017 23:39:02 GMT 表示的是绝对时间(服务器的时间，可能会存在服务器与客户端时间不一致)&emsp;&emsp;Cache-Control Cache-Control:max-age=3600 表示的是客户端的是相对时间，单位是秒;2)协商缓存&emsp;&emsp;Last-Modified If-Modified-Since Last-Modified: Web,26 Jan 2017 00:35:11 GMT&emsp;&emsp;Etag If-None-Match 2、强缓存:&emsp;&emsp;加载资源的时候服务器在响应头中带上Cache-Control、Expires用来表示资源的过期时间(Cache-Control的优先级更高)。2.1 Expires&emsp;&emsp;Expires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。如我现在这个网页的Expires值是：expires:Fri, 14 Apr 2017 10:47:02 GMT。这个时间代表这这个资源的失效时间，只要发送请求时间是在Expires之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱2.2 Cache-Control&emsp;&emsp;Cache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：&emsp;&emsp;no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。&emsp;&emsp;no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。&emsp;&emsp;public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。&emsp;&emsp;private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。&emsp;&emsp;Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 3、协商缓存:&emsp;&emsp;协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。Last-Modify/If-Modify-Since&emsp;&emsp;浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。 &emsp;&emsp;当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 &emsp;&emsp;如果命中缓存，则返回304，并且不会返回资源内容，并且不会返回Last-Modify。 &emsp;&emsp;如果没有命中缓存，则返回200，返回资源内容，并且更新Last-Modify。 Etag和If-None-Match&emsp;&emsp;浏览器第一次请求一个资源的时候，服务器返回的header中会加上Etag，Etag是一个校验码，以保证每一个资源是唯一的只要资源有变化就这个值就会改变 &emsp;&emsp;当浏览器再次请求该资源时，request的请求头中会包含If-None-Match，该值为缓存之前返回的Etag。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。 &emsp;&emsp;如果命中缓存，则返回304，并且不会返回资源内容，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化 &emsp;&emsp;如果没有命中缓存，则返回200，返回资源内容，并且更新ETag 4、为什么要有Etag &emsp;&emsp;你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：&emsp;&emsp;一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；&emsp;&emsp;某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；&emsp;&emsp;某些服务器不能精确的得到文件的最后修改时间。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。]]></content>
  </entry>
  <entry>
    <title><![CDATA[closure]]></title>
    <url>%2F2018%2F10%2F23%2Fclosure%2F</url>
    <content type="text"><![CDATA[以下是自己查阅资料总结归纳关于闭包的相关点： 定义: 《JavaScript高级程序设计》 闭包是指有权限访问另一个函数作用域中的变量的函数; 《JavaScript权威指南》 从技术角度讲,所有的JavaScript函数都是闭包:他们都是对象,他们都关联到作用域链； 《你不知道的JavaScript》 当函数可以记住并访问所在的词法作用域时,就产生了闭包,即使函数是在当前词法作用域之外执行； MDN 闭包是函数和声明该函数的词法环境的组合。 ECMAScript中，闭包指的是： 1、从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。2、从实践角度：以下函数才算是闭包： 1、即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 2、在代码中引用了自由变量 分析:先来看个列子12345678910var scope = 'global_scope';function checkscope()&#123; var scope = 'local_scope'; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 首先分析一下这段代码中执行上下文栈和执行上下文的变化情况。这里给出简要的执行过程: 1、进入全局代码,创建全局执行上下文,全局执行上下文压入执行上下文栈；2、全局执行上下文初始化；3、执行checkscope函数,创建checkscope函数执行上下文,checkscope执行上下文被压入执行上下文栈；4、checkscope执行上下文初始化，创建变量对象、作用域链、this等；5、checkscope函数执行完毕，checkscope执行上下文从执行上下文栈中弹出；6、执行f函数，创建f函数执行上下文，f执行上下文被压入执行上下文栈；7、f执行上下文初始化，创建变量对象、作用域链、this等；8、f函数执行完毕，f函数上下文从执行上下文栈中弹出； 思考：当f函数执行的时候，checkscope函数上下文已经被销毁了，为什么还能读取到checkscope作用域下的scope值呢？ 原来f执行上下文维护了一个作用域链(如下)123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO]&#125; f函数依然可以读到checkscopeContext.AO的值，说明当f函数引用了checkscopeContext.AO中的值的时候，即使checkscopeContext被销毁了，但是JavaScript依然会让checkscopeContext.AO保存在内存中,f函数依然可以通过f函数的作用域链找到它,正是因为JavaScript做到了这一点,从而实现了闭包的这个概念。 总结:某个函数在定义时的词法作用域之外的地方被调用,闭包可以使该函数访问定义时的词法作用域。]]></content>
  </entry>
  <entry>
    <title><![CDATA[message]]></title>
    <url>%2F2018%2F06%2F02%2Fmessage%2F</url>
    <content type="text"><![CDATA[分享一个自己在阅读《JavaScript设计模式与开发实践》中关于订阅发布模式一章中的一个JS设计模式的体现；以下是代码：1234567891011var DEFAULT = 'default';var TYPE = &#123; UNDEFINED: '[object Undefined]', ARRAY: '[object Array]'&#125;;var _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, _toString = Object.prototype.toString, namespaceCache = getCleanObj(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132function getCleanObj() &#123; return Onject.create(null);&#125;function _each(ary, fn) &#123; var ret, item, i = 0, len = ary.length; for (; i &lt; len; i++) &#123; item = ary[i]; ret = fn.call(item, i, item) &#125; return ret;&#125;function _listen(key, fn, cache) &#123; (!cache[key]) &amp;&amp; (cache[key] = []); cache[key].push(fn);&#125;function _remove(key, cache, fn) &#123; if (!cache[key]) &#123; return; &#125; if (fn) &#123; for (var i = cache[key].length; i &gt;= 0; i--) &#123; if (cache[key][i] === fn) &#123; cache[key].splice(i, 1); &#125; &#125; &#125; else &#123; cache[key] = []; &#125;&#125;function _trigger() &#123; var cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _shift = this, stack = cache[key]; if (!stack || !stack.length) &#123; return; &#125; return _each(stack, function () &#123; return this.apply(_self, args); &#125;)&#125;function _create(namespace) &#123; var message = namespace || DEFAULT; // 缓存事件空间 var cache = getCleanObj(), offlineStack = getCleanObj(), ret = &#123; listen: function (key, fn) &#123; _listen(key, fn, cache); if (offlineStack[key]) &#123; _each(offlineStack[key], function () &#123; this(); &#125;) &#125; offlineStack[key] = null; &#125;, one: function (key, fn) &#123; _remove(key, cache); this.listen(key, fn); &#125;, remove: function (key, fn) &#123; _remove(key, cache, fn); &#125;, trigger: function () &#123; var fn, args, key, _self = this; _unshift.call(arguments, cache); args = arguments; key = args[1]; fn = function () &#123; return _trigger.apply(_self, args); &#125; if (TYPE.UNDEFINED === _toString.call(offlineStack[key])) &#123; offlineStack[key] = []; return offlineStack[key].push(fn); &#125; else if (TYPE.ARRAY === _toString.call(offlineStack[key])) &#123; return offlineStack[key].push(fn); &#125; return fn(); &#125; &#125;; return namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret;&#125;;var message = &#123; create: _create, one: function (key, fn) &#123; var message = this.create(); message.one(key, fn); &#125;, remove: function (key, fn) &#123; var message = this.create(); message.remove(key, fn); &#125;, listen: function (key, fn) &#123; var message = this.create(); message.listen(key, fn); &#125;, trigger: function () &#123; var message = this.create(); message.trigger.apply(this, arguments); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript继承]]></title>
    <url>%2F2016%2F10%2F09%2FJavaScriptInherit%2F</url>
    <content type="text"><![CDATA[继承是 OO 语言中的一个最为人津津乐道的概念。许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在 ECMAScript 中无法实现接口继承。 ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 （一）原型链继承这里将父类的实列赋值给子类原型对象实现继承。1234567891011121314151617181920212223var BigA = function () &#123; this._biga = 'biga'; this.name = ['a', 'b']&#125;;BigA.prototype.say = function () &#123; console.log('biga');&#125;;BigA.prototype.Big = 'aaa';var A = function () &#123;&#125;;A.prototype = new BigA();A.prototype.constructor = BigA;var newa = new A(), newb = new A();newa.name.push('newa');console.log(newa);console.log(newa.name);console.log(newb.name); 打印结果如下图：但如上图图所示该继承存在问题： 当原型中存在引用类型值时，其包含引用类型值的原型属性会被所有实列共享。在通过原型来实现继承时，原型实际上会变成另一个类型的实列。于是，原先的实列属性也就顺理成章地变成了现在的原型属性了。 （二）借用构造函数继承在子类型构造函数的内部调用超类型构造函数，通过apply来调整this指向实现继承。123456789101112var BigA = function()&#123; this._biga = '_biga'; this.name = ['a','b'];&#125;; BigA.prototype.say = function()&#123; console.log('bigA');&#125;;BigA.prototype.Big = 'aaa';var C = function()&#123; BigA.apply(this,arguments);&#125;; 打印结果如下图：此种继承方法所存在的问题： 可以从上图中看出子类只继承了在构造函数内定义的属性和方法，超类型原型对象上的属性和方法没有被继承。 （三）组合继承组合继承指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实列属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。1234567891011121314var BigA = function()&#123; this._biga = '_biga', this.name = ['a','b']&#125;; BigA.prototype.say = function()&#123; console.log('bigA');&#125;;BigA.prototype.Big = 'aaa';var D = function()&#123; BigA.apply(this,arguments); //第二次调用了构造方法&#125;;D.prototype = new BigA(); //第一次调用了构造方法D.prototype.constructor = D; 打印结果如下图：此种继承方法所存在的问题： 可以从上图中看出子类中继承了超类型中构造函数中定义的属性和方法（name _biga）与原型对象中的属性和方法。但是在其由超类型原型对象继承来的方法和属性里面出现了(name _biga)属性，这里出现了重复。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数的内部。子类型最终会包含超类型实例对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。 （四）原型式继承道格拉斯·克罗克福德在 2006 年写了一篇文章，题为 Prototypal Inheritance in JavaScript （JavaScript中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数。12345678910111213141516171819202122232425262728var BigA = function()&#123; this._biga = '_biga', this.name = ['a','b']&#125;; BigA.prototype.say = function()&#123; console.log('bigA');&#125;;BigA.prototype.Big = 'aaa';function object(o)&#123; function _F()&#123;&#125;; _F.prototype = o; return new _F();&#125;var _biga4 = new BigA(),E,_E;E = object(_biga4);E.name.push('here is E push');E._biga = 'EEE';_E = object(_biga4)_E.name.push('here is _E push');_E._biga = '_E_E'console.log(E);console.log(_E);console.log(_biga4) 打印结果如下图： 在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样。 （五）寄生组合式继承前面说过，组合继承是 JavaScript 最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。没错，子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。 123456789101112131415161718192021222324var BigA = function()&#123; this._biga = '_biga', this.name = ['a','b']&#125;,F;BigA.prototype.say = function()&#123; console.log('bigA');&#125;;BigA.prototype.Big = 'aaa';function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;F = function()&#123; BigA.apply(this,arguments);&#125;inheritPrototype(F,BigA);var _f = new F();_f.name.push('here is _f push');console.log(_f);console.log(new F()) 打印结果如下图：(左：_f， 右：new F()) 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。]]></content>
      <tags>
        <tag>JavaScript继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript原型]]></title>
    <url>%2F2016%2F09%2F26%2FJavaScript-YuanXing%2F</url>
    <content type="text"><![CDATA[当在JavaScript世界中走过不少旅程之后。再次萌发起研究这部分知识的欲望，翻阅了不少书籍和资料，才搞懂__porto__和prototype的概念。 一切皆为对象 殊不知，JavaScript世界的对象，追根溯源来自于一个null。 万物初生时，一个null对象，凭空而生，接着Object、Function学着null的模样塑造了自己，并且它们彼此之间喜结连理，提供了prototype和constructor，一个给子孙提供了基因，一个则制造万千子孙。 在JS中，null也是作为一个对象存在，基于它基础的子子孙孙，当属对象。乍一看，null像是上帝，而Object和Function犹如JavaScript世界中的亚当与夏娃。 原型指针__proto__在JavaScript中，每个对象都拥有一个原型对象，而指向该原型对象的内部则是__proto__,通过它可以从中继承原型对象的属性，原型是JavsScript中的基因链接，有了这个，才能知道这个对象的祖祖辈辈。从对象中的__porto__可以访问到他所继承的原型对象。12var a = new Array();a.__proto__ === Array.prototype //true 上面代码中，创建了一个Array的实列a,该实例的原型指向了Array.prototype。Array.prototype本身也是一个对象，也有继承的原型：123var a = new Array();a.__proto__.__proto__ === Object.prototype // true// 等同于 Array.prototype.__proto__ === Object.prototype 这就说明了，Array本身也是继承自Object的，那么Object的原型指向的是谁呢？123var a = new Array();a.__proto__.__proto__.__proto__ === null // true// 等同于 Object.prototype.__proto__ === null 所以说，Javascript中的对象，追根溯源都是来自于一个null对象。佛曰：万物皆空，善哉善哉。 除了使用.__porto__方式访问对象的原型，还可以通过Object.getPrototypeOf方法来获取对象的原型，以及通过Object.setPrototypeOf方法来重写对象的原型。 值得注意的是，按照语言标准，__porto__属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两个下划线，表示其本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeOf和Object.setPrototypeOf,进行原型对象的读写操作。这里__porto__属性来描述对象中的原型，是因为这样来得更加形象，而且容易理解。 原型对象 prototype函数作为JavaScript中的一等公民，它既是函数又是对象，函数的原型指向的是Function.prototype函数实例的原型12var Foo = function() &#123;&#125;Foo.__proto__ === Function.prototype // true 函数实例除了拥有__porto__属性之外，还拥有prototype属性。通过该函数构造的新的实例对象，其原型指针__porto__会指向该函数的prototype属性。函数实例的prototype属性123var Foo = function() &#123;&#125;var a = new Foo();a.__proto__ === Foo.prototype; // true 而函数的prototype属性，本身是一个由Object构造的实列对象。函数实例的prototype属性指向的对象12var Foo = function() &#123;&#125;Foo.prototype.__proto__ === Object.prototype; // true prototype属性很特殊，它还有一个隐式的constructor,指向了构造函数本身。函数实例的prototype属性指向的对象的constructor属性12345var Foo = function() &#123;&#125;var a = new Foo();Foo.prototype.constructor === Foo; // truea.constructor === Foo; // truea.constructor === Foo.prototype.constructor; // true PS:a.construcror属性并不属于a（a.hasOwnProperty(“constructor”) === false），而是读取的a.__proto__.constructor，所以上图用虚线表示a.constructor，方便理解。 原型链概念：原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每个构造函数都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针(constructor),而实例都包含一个指向原型对象的内部指针(__proto__)。 那么，假如我们让原型对象等于另一个类型的实列，此时的原型对象将包含一个指向另一个原型的指针，相应的，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立。如此层层递进，就构造了实例与原型的链条，这就是原型链的基本概念。 意义：“原型链”的作用在于，当读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。以此类推，如果直到最顶层的Object.prototype还是找不到，则返回undefine。 亲子鉴定在JavaScript中，也存在鉴定亲子之间DNA关系的方法： instanceof 运算符返回一个布尔值，表示一个对象是否由某个构造函数创建。 Object.isPrototypeOf() 只要某个对象处在原型链上，isProtypeOf都返回true12345var Bar = function()&#123;&#125;, b = new Bar(); b instanceof Bar // true Bar.prototype.isPrototypeOf(b) // true Object.prototype.isPrototypeOf(Bar) // true 要注意，实例b的原型是Bar.prototype而不是Bar 一张历史悠久的图 这是一张描述了Object、Function以及一个函数实例Foo于他们原型之间的联系。如果理解了上面的概念。这张图是不难读懂。 从上图中，能看到一个有趣的地方。 Function.prototype._proto__指向了Object.prototype，这说明Function.prototype是一个Object实例，那么应当是先有的Object再有Function。 但是Object.prototype.constructor.__proto__又指向了Function.prototype。这样看来，没有Function，Object也不能创建实例。 这就产生了一种类「先有鸡还是先有蛋」的经典问题，到底是先有的Object还是先有的Function呢？这么哲学向的问题，留给你思考了。 我只是感慨：越往JavaScript的深处探索，越觉得这一门语言很哲学。]]></content>
      <tags>
        <tag>JavaScript原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式与开发实践--记录]]></title>
    <url>%2F2016%2F09%2F22%2FJavaScriptDesignPattern%2F</url>
    <content type="text"><![CDATA[第一章 面向对象的JavaScript动态类型与静态类型语言和鸭子类型 静态类型语言 特点： 在编译时，便已确定变量的类型 优点：首先是在编译时就能发现类型不匹配的错误，编译器可以帮助提前避免程序在运行期间有可能发生的错误。 其次，如果程序中明确地规定了数据类型，编译器还可以针对这些信息进行一些优化处理，提升程序执行速度。 缺点：首先迫使程序员依照强契约来编写程序。增加额外的代码（类型声明） 动态类型语言 特点：变量类型要到程序运行时，待变量被赋值之后，才会具有某种类型 优点：代码量少，看起来简洁 缺点：无法保证变量的类型 鸭子类型 通俗的说法是“如果走起来像鸭子，叫起来像鸭子，那么它就是一只鸭子” 动态类型语言对变量类型的宽裕给实际编码带来了很大的灵活性，由于无需进行类型检测，我们可以尝试调用任意对象的任意方法，而无需考虑它原本是否被设计为拥有该方法。 鸭子类型js模拟 123456789101112131415161718192021222324var duck = &#123; duckSinging: function()&#123; console.log('嘎嘎嘎'); &#125;&#125;;var chicken = &#123; duckSinging: function()&#123; console.log('嘎嘎嘎'); &#125;&#125;;var choir = [];var joinChoir = function(animal)&#123; if(animal &amp;&amp; typeof animal.duckSinging === 'function')&#123; choir.push(animal); console.log('恭喜加入合唱团'); console.log('合唱团已有承你成员数量: '+choir.length); &#125;&#125;;joinChoir(duck);joinChoir(chicken); 多态 释意“多态”一词源于希腊文ploymorphism,拆开来看是ploy(复数)+morph(形态)+ism从字面上我们可以理解为复数形态。多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。 一段“多态”的js代码一段“多态”的js代码1234567891011121314151617(function()&#123; var makeSound = function(animal)&#123; if(animal instanceof Duck)&#123; console.log('嘎嘎嘎'); &#125;else if(animal instanceof Chicken)&#123; console.log('咯咯咯'); &#125; &#125;; var Duck = function()&#123;&#125;; var Chicken = function()&#123;&#125;; makeSound(new Duck()); makeSound(new Chicken()); $testnEnd();&#125;)(); “多态”的js代码 优化代码改进 把不变的部分隔离出来12345678910111213141516171819202122(function()&#123; var makeSound = function(animal)&#123; if(animal.sound instanceof Function) &#123; animal.sound(); &#125; &#125;; var Duck = function()&#123;&#125;; Duck.prototype.sound = function()&#123; console.log('嘎嘎嘎'); &#125;; var Chicken = function()&#123;&#125;; Chicken.prototype.sound = function()&#123; console.log('咯咯咯'); &#125;; makeSound(new Duck()); makeSound(new Chicken()); $testnEnd();&#125;)(); 注释这段代码确实体现了“多态性”，当我们分别向鸭和鸡发出“叫唤”的消息时，它们根据此消息作出了各自不同的反应。但这样的“多态性”是无法令人满意的，如果后来又增加了一只动物，比如狗，显然狗的叫声是“汪汪汪”，此时我们必须得改动makeSound函数，才能让狗也发出叫声。修改代码总是危险的，修改的地方越多，程序出错的可能性就越大，而且当动物的种类越来越多时，makeSound有可能变成一个巨大的函数多态背后的思想是将“做什么”和“谁去做以及怎么去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。在这个故事中，动物会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分分隔离出来，把可变的部分封装起来，这给予我们扩展程序的能力，程序看起来是可生长的，也是符合开发-封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全很多。 第二章 this、call和applythisJS中this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this的指向除去不常用的with和eval情况，this的指向大致可以分为以下4种 作为对象发方法调用 作为普通函数调用 构造器调用 Function.prototype.call或Function.prototype.apply调用 作为对象发方法调用作为对象的方法调用 12345678910111213141516171819202122//当函数作为对象的方法被调用时，this指向该对象：(function()&#123; var makeSound = function(animal)&#123; if(animal.sound instanceof Function) &#123; animal.sound(); &#125; &#125;; var Duck = function()&#123;&#125;; Duck.prototype.sound = function()&#123; console.log('嘎嘎嘎'); &#125;; var Chicken = function()&#123;&#125;; Chicken.prototype.sound = function()&#123; console.log('咯咯咯'); &#125;; makeSound(new Duck()); makeSound(new Chicken());&#125;)(); 作为普通函数调用作为普通函数调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的this总是指向全局对象。window.name = 'globalName';(function()&#123; var getName = function()&#123; return this.name; &#125; console.log(getName()); //输出：gloalName&#125;)();(function()&#123; var myObject = &#123; name : 'seven', getName: function()&#123; return this.name; &#125; &#125;; var getName = myObject.getName; console.log(getName()); //globalName var getName2 = myObject.getName(); console.log(getName2); //seven&#125;)();window.id = 'window';(function()&#123; document.getElementById('div1').onclick = function()&#123; console.log(this.id); //输出:'div1' var callback = function()&#123; console.log(this.id); //输出:'window' &#125;; callback(); &#125;;&#125;)();(function()&#123; document.getElementById('div2').onclick = function()&#123; var that = this; // 保存div引用 var callback = function()&#123; console.log(that.id); //输出div2 &#125;; callback(); &#125;;&#125;)(); 构造器调用构造器调用123456789101112131415161718192021222324252627282930313233343536373839404142//构造器里this指返回的这个对象(function()&#123; var MyClass = function()&#123; this.name = 'seven'; &#125;; var obj = new MyClass(); console.log(obj.name); //输出：seven&#125;)(); //注意1：//如果构造器显示的返回了一个object类型的对象，那么此处运算结果最终会返回这个对象，而不是this(function()&#123; var MyClass = function()&#123; this.name1 = 'seven'; return &#123; name1: 'anne' &#125; &#125;; var obj = new MyClass(); console.log(obj.name1); var returnObj = MyClass(); console.log(returnObj.name1);&#125;)();//注意2://如果构造器不显示的返回任何数据，或者返回一个非对象类型的数据，就不会造成上述问题(function()&#123; var MyClass = function()&#123; this.name2 = 'seven'; return 'anne'; //返回string类型 &#125;; var obj = new MyClass(); console.log(obj.name2); //输出：seven var returnString = MyClass(); console.log(returnString); //输出anne&#125;)(); 丢失的this这是经常遇到的问题，我们先看下面代码：丢失的this12345678910111213(function()&#123; var obj = &#123; myName: 'seven', getName: function()&#123; return this.myName; &#125; &#125;; console.log(obj.getName()); //输出：seven var getName2 = obj.getName; console.log(getName2()); //输出： undefined&#125;)(); 当调用obj.getName时，getName方法是作为obj对象的属性被调用的，此时this指向obj对象。当用另外一个变量getName2来引用obj.getName,并且调用getName2时，此时是作为普通方法调用的this指向全局的window。 document.getElementById代替函数 1234567891011121314151617181920212223242526//错误示列(function()&#123; var getId = document.getElementById; getId('div'); //此时会报错&#125;)(); // 改进01(function()&#123; var getId = function(id)&#123; return document.getElementById(id); &#125;; var a = getId('div1');&#125;)(); //改进02 (function()&#123; document.getElementById = (function(func)&#123; return function()&#123; return func.apply(document, arguments); &#125; &#125;)(document.getElementById); var getId = document.getElementById; console.log(getId('div1')); console.log(document.getElementById('div1')); &#125;)(); 改进02:原本getElementById是作为document对象里的属性被调用的，但是上面的代码将getElementById中的this指向了document,所以上面代码第一个return返回的是一个this指document的getElementById函数;此时该函数可以不用作为属性被调用，也能执行此处将传进去的func函数指向了document call和applyECMAScript3给Function的原型定义了两个方法，它们是Function.prototype.call和Function.prototype.apply。 call和apply的区别Function.prototype.call和Function.prototype.apply都是非常常用的方法。它们的作用一模一样，区别仅在于传入的参数形式的不同。 apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数：apply12345var func = function(a,b,c)&#123; alert([a,b,c]); &#125;func.apply(null,[1,2,3]); //输出[1,2,3] 在这段代码中，参数1，2，3被放在数组中一起传入func函数，它们分别对应func参数列表中的a,b,c。 call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内this指向。从第二个参数开始往后，每个参数被依次传入函数：apply12345var func = function(a,b,c)&#123; alert([a,b,c]); &#125;func.call(null,1,2,3); //输出[1,2,3] 当调用一个函数时，JavaScript的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript的参数在内部就是用一个数组来表示的。从这个意义上说，apply比call的使用率更高，我们不必关心具体有多少参数被传入函数，只要用apply一股脑的推过去就可以了。 当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window。（严格模式下任然为null） 12345var func = function(a,b,c)&#123; alert( this === window );&#125;func.apply(null,[1,2,3]); //出入true call和apply的用途 改变this指向 1234567891011121314var obj1 = &#123; name: 'sven'&#125;;var obj2 = &#123; name: 'anne'&#125;;window.name = 'window';var getName = function()&#123; alert(this.name);&#125;;getName(); //输出：windowgetName.call(obj1); //输出：svengetName.call(obj2); //输出：anne Function.prototype.bind bind实现12345678910111213141516Function.prototype.bind = function(context)&#123; var self = this; //保存原函数 return function()&#123; //返回一个新的函数 return self.apply(context, arguments); //放执行新的函数的时候，会把之前传入的context //当作新函数体内的this &#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function()&#123; alert(this.name); &#125;;window.name = 'window';func(); //输出：windowfunc.bind(obj)(); //输出：sven 我们通过Function.prototype.bind来“包装”func函数。并且传入一个对象context当作参数，这个context对象就是我们想修正的this指向。 在Function.prototype.bind的内部实现中，我们先把func函数的引用保存起来，然后返回一个新的函数。当我们在将来执行func函数时，实际上先执行的是这个刚刚返回的新函数。 在新函数内部，self.apply(context,arguments)这句代码才是执行原来的func函数，并且指定context对象为func函数体内的this。 bind方法优化12345678910111213141516171819202122232425262728Function.prototype.bind = function()&#123; var self = this, //保存原函数 context = [].shift.call(arguments), //需要绑定的this上下文 args = [].slice.call(arguments); //剩余的参数转成数组 return function()&#123; //返回一个新的函数 var _args = [].concat.call(args, [].slice.call(arguments)); return self.apply(context, _args); &#125;&#125;var obj = &#123; name: 'sven'&#125;;window.name = 'window';var func = function(a,b,c,d)&#123; console.log(this.name); console.log( [a,b,c,d] );&#125;;func(1,2,3,4); //window //[1,2,3,4] func.bind(obj,'x','y')('a','b'); //sven //['x','y','a','b'] 优化后的bind方法允许可以往func函数中预先填入一些参数 借用其他对象的方法 第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果： 借用构造函数1234567891011var A = function(name)&#123; this.name = name;&#125;;var B = function()&#123; A.apply(this,arguments);&#125;;B.prototype.getName = function()&#123; return this.name;&#125;;var b = new B('sven');console.log(b.getName()); //输出： 'sven' 第二种运用场景 借用方法 Array.prototype.push:1234(function()&#123; Array.prototype.push.call(arguments,3); console.log(arguments); //输出[1,2,3]&#125;)(1,2); 在操作arguments的时候，我们经常非常频繁地找Array.prototype对象借用方法。 想把arguments转成真正的数组的时候，可以借用Array.prototype.slice方法； 想截去argumrnts列表中的头一个元素时，又可以借用Array.prototype.shift方法。 注意：Array.prototype.push方法的借用需要满足以下两个条件： 对象本身要可以存取属性； 对象的length属性可读写。 var a = 1; Array.prototype.push.call(a, 'first'); console.log(a.length); //输出: undefined console.log(a[0]); //输出：undefined 第三章 闭包和高阶函数 闭包对于JavaScript程序员来说，闭包是一个必须征服的概念。闭包的形参与变量的作用域以及变量的生存周期密切相关。 变量的作用域变量的作用域，就是指变量的有效范围，我们最常谈到的是在函数中声明的变量作用域。当在函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量，这当然是一种命名冲突的做法。 另外一种情况就是用var关键字在函数中声明变量，这时候的变量即是局部变量，只有改函数内部才能访问到这个变量，在函数外面是访问不到的。代码如下： var func = function(){ var a = 1; console.log(a); }; func(); //输出：1 console.log(a); //输出： Uncaught ReferenceError : a is not defined 在JavaScript中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的。 下面这段包含了嵌套函数的代码，也许能帮助我们加深对变量搜索过程的理解： var a = 1; var func1 = function(){ var b = 2; var func2 = function(){ var c = 3; console.log(b); //输出：2 console.log(a); //输出：1 } func2(); console.log(c); //Uncaught ReferenceError: c is not defined } func1(); 变量的生存周期除了变量的作用域之外，另外一个根闭包有关的概念是变量的生存周期。对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁： var func = function(){ var a = 1; //退出函数后局部变量a将被销毁 console.log(a); } func(); 接下来看下一段代码 var func = function(){ var a = 1; return function(){ a++; console.log(a); } } var f = func(); f(); //输出：2 f(); //输出：3 f(); //输出：4 跟我们之前的推论相反，当退出函数后，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行var f = func();时，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。 &lt;!-- 闭包的经典应用 --&gt; &lt;html&gt; &lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;script&gt; var nodes = document.getElementsByTagName('div'); for( var i = 0;len = nodes.length;i&lt;len;i++){ nodes[i].onclick = function(){ console.log(i); } }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 测试这段代码就会发现，无论点击哪个div最后打印的结果都是5。这是因为div节点的onclick事件是异步触发的，当事件被触发的时候，for循环早已结束，此时变量i的值已经是5，所以在div的onclick事件函数中顺着作用域链从内到外查找变量i时，查到的值都是5. /* 解决办法 */ for(var i=0,len=nodes.length; i&lt;len; i++){ (function(i){ nodes[i].onclick = function(){ console.log(i); } })(i) } 在闭包的帮助下，把每次循环的i值都封闭起来。当在事件函数中顺着作用域链中从内到外查找变量i时，会先找到被封闭在闭包环境中的i，如果有5个div，这里的i就分别是0，1，2，3，4。 闭包的更多作用 封装变量闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的简单函数： var mult = function(){ var a = 1; for(var i=0,l = arguments.length; i&lt;l; i++){ a = a*arguments[i]; } return a; }; mult函数接受一些number类型的参数，并返回这些参数的乘积。现在我们觉得对于相同的参数来说，可以加入缓存机制来提高这个函数的性能： var cache = {}; var mult = function(){ var args = Array.prototype.join.call(arguments, ','); if(cache[args]){ console.log('cache'); return cache[args]; } var a = 1; for(var i=0,l=arguments.length; i&lt;l; i++){ a = a * arguments[i]; } return cache[args] = a; }; 我们看到cache这个变量仅仅在mult函数中被使用，与其让cache变量跟mult函数一起平行地暴露在全局作用域下，不如把它封装在mult函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改： var mult = (function(){ var cache = {}; return function (){ var args = Array.prototype.join.call(arguments, ','); if( args in cache){ return cache[args]; } var a = 1; for(var i=0,l=arguments.length; i&lt;l; i++){ a = a * arguments[i]; } return cache[args] = a; } })(); 提炼函数是代码重构中一种常见的技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用最好是把他们用闭包封闭起来。代码如下： var mult = (function(){ var cache = {}, calculate = function(){ //封闭calculate函数 var a = 1; for(var i=0,len=arguments.length; i&lt;len; i++){ a = a * arguments[i]; } return a; }; return function (){ var args = Array.prototype.join.call(arguments, ','); if( args in cache){ console.log('cache') return cache[args]; } return cache[args] = calculate.apply(null,arguments); } })(); 延续局部变量的寿命img对象经常用于进行数据上报，如下图所示：var report = function(src){ var img = new Image(); img.src = src; }; report('http://xxx.com/getUserInfo'); 但是通过查询后台记录我们得知，因为一些低版本浏览器的实现存在bug，report函数并不是每一次都成功发起http请求。丢失数据的原因是img是report函数中的局部变量，当report函数的调用结束后，img局部变量即被销毁，而此时或许还没来得及发出http请求，所以此次请求就会丢失。现在我们把img变量用闭包封闭起来。便能解决请求丢失问题：var report = (function(){ var imgs = []; return function(src){ var img = new Image(); imgs.push(img); img.src = src; } )(); 闭包和面向对象设计以下是通过闭包实现面向对象 var extent = (function(){ var a = 1; return { add: function(){ a++; console.log(a); } } })(); extent.add(); //输出2 extent.add(); //输出3 extent.add(); //输出4 换成面向对象的写法，就是： var extent= { value:0, add:function(){ this.value++; console.log(this.value); } }； /* 或者 */ var Extent = function(){ this.value = 0; }; Extent.prototype.call = function(){ this.value++; console.log(this.value); }; var extent = new Extenet(); extent.add(); extent.add(); extent.add(); 高阶函数高阶函数是指至少满足下列条件之一的函数。 函数可以作为参数被传递； 函数可以作为返回值输出。 JavaScript语言中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当做参数传递，还是让函数的执行结果返回另外一个函数。这两种情形都有很多应用场景。下面就列举一些高阶函数的应用场景。 函数作为参数传递把函数当作参数传递，这代表我们可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。其中一个重要的场景就是回调函数。 回调函数 var appendDiv = function(callback){ for(var i = 0;i&lt;100;i++){ var div = document.createElement('div'); div.innerHTML = i; document.body.appendChild(div); if(typeof callback === 'function' ){ callback(div); { } }; appendDiv(function(node){ node.style.display = 'none'; }) 可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在了回调函数中。“委托”给appendDiv方法，appendDiv方法当然知道节点什么时候创建好，所以在节点创建好的时候，appendDiv会执行之前客户传入的回调函数。 Array.prototype.sortArray.prototype.sort接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。从Array.prototype.sort的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入Array.prototype.sort,使Array.prototype.sort方法成为了一个非常灵活的方法，代码如下 // 从小到大排列 [1,4,3].sort(function(a,b){ return a - b; }); //输出[1,3,4] //从大到小排列 [1,4,3].sort(function(){ return b - a; }); //输出[4,3,1]]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>